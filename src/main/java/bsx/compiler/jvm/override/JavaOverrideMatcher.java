package bsx.compiler.jvm.override;

import bsx.BsValue;
import bsx.load.LoadingContext;
import bsx.util.Bytecode;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodNode;

import javax.annotation.Nullable;
import java.lang.invoke.MethodType;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;

public class JavaOverrideMatcher {
    
    public static void addBridges(List<ClassNode> classes, LoadingContext context) {
        TypeHierarchyResolver resolver = new TypeHierarchyResolver(context, classes);
        for (ClassNode node : classes) {
            if ((node.access & Opcodes.ACC_INTERFACE) == 0) {
                addBridges(resolver, node);
            }
        }
    }
    
    private static void addBridges(TypeHierarchyResolver resolver, ClassNode cls) {
        List<MethodNode> additionalMethods = new ArrayList<>();
        List<Class<?>> classes = resolver.getLoadedSuperClasses(cls.name);
        for (MethodNode node : cls.methods) {
            MethodType type = null;
            for (Class<?> superClass : classes) {
                Result result = findMatching(superClass, node);
                type = result.type();
                if (!result.shouldContinue()) break;
            }
            if (type != null) {
                additionalMethods.add(BridgeFactory.makeBridgeFor(cls.name, node, Bytecode.getType(type)));
            }
        }
        cls.methods.addAll(additionalMethods);
    }
    
    private static Result findMatching(Class<?> cls, MethodNode node) {
        if ((node.access & Opcodes.ACC_STATIC) != 0) return new Result(true, null);
        if ((node.access & Opcodes.ACC_PUBLIC) == 0 && (node.access & Opcodes.ACC_PROTECTED) == 0) return new Result(true, null);
        if ((node.access & Opcodes.ACC_ABSTRACT) != 0) return new Result(true, null);
        Type type = Type.getMethodType(node.desc);
        for (Method method : cls.getMethods()) {
            if (Modifier.isStatic(method.getModifiers())) continue;
            if (!Modifier.isPublic(method.getModifiers()) && !Modifier.isProtected(method.getModifiers())) continue;
            if (!Objects.equals(node.name, method.getName())) continue;
            if (method.isVarArgs() || method.getParameterCount() != type.getArgumentTypes().length) continue;
            if (method.getReturnType() == BsValue.class && Arrays.stream(method.getParameterTypes()).allMatch(arg -> arg == BsValue.class)) {
                // Method already is in BS form
                return new Result(false, null);
            } else if (!method.isBridge()) {
                // This also filters out bridges generated by the BSX compiler to override java methods
                return new Result(false, MethodType.methodType(method.getReturnType(), method.getParameterTypes()));
            }
        }
        return new Result(true, null);
    }
    
    private record Result(boolean shouldContinue, @Nullable MethodType type) {}
}
